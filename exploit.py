import pwn
from main import mulECPointScalar

# the NIST p-256 curve, (a, b, prime)
NIST_256_CURVE = (-3, 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b, 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff)
# p, chosen securely and arbitrarily...
P = (0x1c1259e8bc9ba0823e5ad8480586b26d1f33f52600a3204aeb57c8f4d87434b9, 0xb422ac1753c053f6270bbcab5aa63cfad40534a8d1df8e5425ed597b6c5cf4c2)
# q, not any q in particular...
Q = (0xc97445f45cdef9f0d3e05e1e585fc297235b82b5be8ff3efca67c59852018192, 0xb28ef557ba31dfcbdd21ac46e2a91e3c304f44cb87058ada2cb815151e610046)
# given in problem
backdoor = 0x5b8c0adce49783789b6995ac0ec3ae87d6005897f0f2ddf47e2acd7b1abd

# P is divisible by 4 and so (x3+ax+b)^((p+1)>>2)modp
def get_y(curve, x):
    return pow(pow(x, 3) + (curve[0] * x) + curve[1], (curve[2] + 1) >> 2, curve[2])

con = pwn.connect("lair.sdc.tf", 1337)
found = False
while not found:
  con.recvuntil("(in hexadecimal):".encode())
  con.send('0\n'.encode())
  con.recvuntil('thinking of '.encode())

  rand_val = con.recvuntil('\n'.encode()).decode()[:-1][2:]
  #These are all of the 256 possible states for the first guess
  state_table = []
  for i in range(16):
      for j in range(16):
          guess_rand_val = int(str(i) + str(j) + rand_val, 16)
          state_table.append( mulECPointScalar(NIST_256_CURVE, [guess_rand_val, get_y(NIST_256_CURVE, guess_rand_val)], backdoor)[0] )
  con.recvuntil('thinking of (in hexadecimal):'.encode())
  con.send('0\n'.encode())
  con.recvuntil('thinking of '.encode())
  real_val = con.recvuntil('\n'.encode())
  real_val = real_val.decode()[:-1]
  real_state = 0
  #Only one of the 256 states can be correct for the second guess
  for state in state_table:
      guess = mulECPointScalar(NIST_256_CURVE, Q, state)[0] & 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
      if hex(guess) == real_val:
          real_state = state
          found = True
          break

#Jump the ball on the third guess and get the state
future_state = mulECPointScalar(NIST_256_CURVE, P, real_state)[0]
con.send((hex(mulECPointScalar(NIST_256_CURVE, Q, future_state)[0] & 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)[2:] + '\n').encode())
con.recvuntil('sir.\n'.encode())
print(con.recvline()[:-1])