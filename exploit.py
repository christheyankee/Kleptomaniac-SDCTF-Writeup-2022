import pwn
from main import mulECPointScalar, NIST_256_CURVE, P, Q

backdoor = 0x5b8c0adce49783789b6995ac0ec3ae87d6005897f0f2ddf47e2acd7b1abd

# P is divisible by 4 and so (x3+ax+b)^((p+1)>>2)modp
def get_y(curve, x):
    return pow(pow(x, 3) + (curve[0] * x) + curve[1], (curve[2] + 1) >> 2, curve[2])

if __name__ == "__main__" :
    found = False
    while not found:
        con = pwn.connect("lair.sdc.tf", 1337)
        con.recvuntil("(in hexadecimal):".encode())
        con.send('0\n'.encode())
        con.recvuntil('thinking of '.encode())
        rand_val = con.recvuntil('\n'.encode()).decode()[:-1][2:]
        #These are all of the 256 possible states for the first guess
        logger = pwn.log.progress("Generating states")
        state_table = []
        for i in range(16):
            for j in range(16):
                logger.status(str((i * 16) + (j + 1)))
                guess_rand_val = int(str(i) + str(j) + rand_val, 16)
                state_table.append(mulECPointScalar(NIST_256_CURVE, [guess_rand_val, get_y(NIST_256_CURVE, guess_rand_val)], backdoor)[0])
        con.recvuntil('thinking of (in hexadecimal):'.encode())
        con.send('0\n'.encode())
        con.recvuntil('thinking of '.encode())
        real_val = con.recvuntil('\n'.encode())
        real_val = real_val.decode()[:-1]
        real_state = 0
        logger.success()
        #Only one of the 256 states can be correct for the second guess
        logger = pwn.log.progress("Obtaining correct state")
        for i, state in enumerate(state_table):
            logger.status(str(i + 1))
            guess = mulECPointScalar(NIST_256_CURVE, Q, state)[0] & 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
            if hex(guess) == real_val:
                real_state = state
                found = True
                break
        logger.success()
        #Jump the ball on the third guess and get the state
        future_state = mulECPointScalar(NIST_256_CURVE, P, real_state)[0]
        con.send((hex(mulECPointScalar(NIST_256_CURVE, Q, future_state)[0] & 0x00ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)[2:] + '\n').encode())
        if found:
            con.recvuntil('sir.\n'.encode())
            print(con.recvline()[:-1].decode())
        else:
            con.recvuntil('thinking of '.encode())
            con.recvline()
            print("Rerunning algorithm, we missed the value")
        con.close()